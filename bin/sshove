#! /bin/sh

script="$0";
argc=$#;
argv=$*;

# Make sure we won't exit automatically on errors.
set +e;

# Set up some readonly helper variables.
# Create a readonly variable with the name of this programs so that we can
# easily rename it it will.
readonly program='sshove';
readonly space=' ';
readonly tab='	';
readonly newline='
';
readonly pid=$$;
readonly IFS_default="${IFS}";
readonly upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
readonly lower='abcdefghijklmnopqrstuvwxyz';
readonly number='0123456789';

# Set IFS just to make sure that it is sane.
IFS="${IFS_default}";

# Set $LC_CTYPE to something sane if it is not already defined as tr complains
# on OSX if it is not set.
LC_CTYPE=${LC_CTYPE:-'C'};

# Create our own 'realpath' command to work around the absence of 'realpath'
# on some systems like OSX.
realpath() {
  my_name=`basename "${1}"`;
  my_dir=`dirname "${1}"`;

  if cd "${my_dir}" 2>/dev/null; then
    my_dir=`pwd`;
  fi;

  eval echo "${my_dir}/${my_name}";
}

# Create a generic function to generate a pseudo random string.  The default
# solaris tr doesn't seem to support charater sets, so all charaters must be
# manually listed out.  It also freaks out with many binary charaters, so we
# limit the input with strings.
randstr() {
  strings < /dev/urandom | \
  tr -cd "${upper}${lower}${number}" | \
  dd count=1 bs=8 2>/dev/null;
  echo;
}

# If we can't stat $script_path, it must have come from $PATH.  Let's find
# where we live.
if ! [ -x "${script}" ]; then
  script_path=`which "${script}"`;
else
  script_path=`realpath "${script}"`;
fi;
script_dir=`dirname "${script_path}"`;
script_name=`basename "${script_path}"`;
prefix=`dirname "${script_dir}"`;

# Locate $config_base and load our config file.
for dir in ~/.ssh ~/etc "${prefix}/etc"; do
  dir="${dir}/.${program}";
  if [ -d "${dir}" ]; then
    if [ -r "${dir}/${program}.conf" ]; then
      . "${dir}/${program}.conf";
    fi;

    if [ -w "${dir}" ]; then
      config_base=${config_base:-${dir}};
    fi;
  fi;
done;
config_base=${config_base:-`realpath ~/.ssh/${program}`};

# Apply our defaults if a value was not found in the config file.
ssh_command=${ssh_command:-'ssh'};
tmpdir=${tmpdir:-"${config_base}/tmp"};
source_path=~;
rsync_command=${rsync_command:-'rsync'};
rsync_logfile=${rsync_logfile:-"${tmpdir}/rsync.log"};
rsync_options=${rsync_options:-'-auq'};
include_file=${include_file:-"${config_base}/include"};
exclude_file=${exclude_file:-"${config_base}/exclude"};
rsyncd_config=${rsyncd_config:-"${tmpdir}/rsyncd.conf"};
rsyncd_passwd=${rsyncd_passwd:-"${tmpdir}/rsyncd.passwd"};
rsyncd_pidfile=${rsyncd_pidfile:-"${tmpdir}/rsyncd.pid"};
rsyncd_port=${rsyncd_port:-'1897'};
rsyncd_user=${rsyncd_user:-`randstr`};
rsyncd_pass=${rsyncd_pass:-`randstr`};
rsync_filter=${rsync_filter:-"${tmpdir}/rsync.filter"};
rsync_dirfilter=${rsync_dirfilter:-".${program}.filter"};


# If we have anything other than exactly 1 argument, then just call ssh as we
# we don't know what arguments might be necessary to preform our rsync.
if [ "${argc}" != '1' ]; then
  exec "${ssh_command}" ${argv};
  exit 0;
fi;

# Make sure our $config_base and $tmpdir exist. 
for dir in "${config_base}" "${tmpdir}"; do
  dir=`realpath "${dir}"`;
  if ! [ -d "${dir}" ]; then
    if ! mkdir -m 700 "${dir}"; then
      echo "error: '${dir}' does not exist and could not be created" >&2;
    fi;
  fi;
done;

# Generate our system filters. Start by defining out per-directory filter file.
filters="dir-merge ${rsync_dirfilter}${newline}";

# We always exclude our tmp directory and files.
base=`realpath "${source_path}"`;
for name in tmpdir rsyncd_pidfile rsyncd_config rsyncd_passwd rsync_filter; do
  eval value=\$$name;
  value=`realpath "${value}"`;
  value="${value#${base}}";
  filters="${filters}- ${value}${newline}";
done

# Create our _filters files
echo "${filters}" > "${rsync_filter}" 2>/dev/null;

case "`uname`" in
  # cygwin is a special case because multiplexing does not work.
  [Cc][Yy][Gg][Ww][Ii][Nn]*)
    mode=simple;
  ;;
esac;

case "`${ssh_command} -V 2>&1`" in
  # Sun SSH does not support multiplexing
  [Ss][Uu][Nn]*)
    mode=simple;
  ;;
esac;
  
case "${mode}" in
  [Ss][Ii][Mm][Pp][Ll][Ee])
    # Start out by adding the rsync_filter file.
    filters='';
    if [ -r "${rsync_filter}" ]; then
      filters="  filter = . ${rsync_filter}";
    fi;

    # Now we add in our customer include and exclude files if they are defined.
    if [ -r "${include_file}" ]; then
      filters="${filters}${newline}  include from = ${include_file}";
    fi;
    if [ -r "${exclude_file}" ]; then
      filters="${filters}${newline}  exclude from = ${exclude_file}";
    fi;   
    
    # Finally, add in a default exclude.
    filters="${filters}${newline}  exclude = /*";
    
    # Create our rsyncd configuration/
    cat << __EOF__ > "${rsyncd_config}";
address = 127.0.0.1
use chroot = yes
max connections = 1
pid file = ${rsyncd_pidfile}

[${program}]
  path = ${source_path}
  list = false
  read only = yes
  auth users = ${rsyncd_user}
  secrets file = ${rsyncd_passwd}
${filters}
  post-xfer exec = kill \`cat "${rsyncd_pidfile}"\`
__EOF__

    # Make sure our passwd file is up to date and secure.
    echo "${rsyncd_user}:${rsyncd_pass}" > "${rsyncd_passwd}";
    chmod 600 "${rsyncd_passwd}";

    # Fire up rsync in daemon mode.
    "${rsync_command}" --daemon --config="${rsyncd_config}" \
    --port="${rsyncd_port}";

    "${ssh_command}" -R "127.0.0.1:${rsyncd_port}:127.0.0.1:${rsyncd_port}" -t $argv 'RSYNC_PASSWORD="'${rsyncd_pass}'" rsync '${rsync_options}' rsync://'${rsyncd_user}'@127.0.0.1:'${rsyncd_port}'/'${program}'/ ./ & exec "${SHELL}" -l';
  ;;

  *)
    # Start out by adding the rsync_filter file.
    filters='';
    if [ -r "${rsync_filter}" ]; then
      filters="--filter='. ${rsync_filter}'";
    fi;

    # Now we add in our customer include and exclude files if they are defined.
    if [ -r "${include_file}" ]; then
      filters="${filters} --include-from='${include_file}'";
    fi;
    if [ -r "${exclude_file}" ]; then
      filters="${filters} --exclude-from='${exclude_file}'";
    fi;   
    
    # Finally, add in a default exclude.
    filters="${filters} --exclude='/*'";

    # Set up a host specific contol file.
    control="${tmpdir}/%r@%n-${pid}.sock";

    "${ssh_command}" -o ControlMaster=auto -o ControlPath="${control}" -o PermitLocalCommand=yes -o LocalCommand="${rsync_command} ${rsync_options} ${filters} --rsh '${ssh_command} -o ControlPath=\"${control}\"' ./ '%r@%n:./' &" $argv;
  ;;
esac;
